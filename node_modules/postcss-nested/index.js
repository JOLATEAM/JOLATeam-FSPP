<<<<<<< HEAD
const { Rule, AtRule } = require('postcss')
let parser = require('postcss-selector-parser')

/**
 * Run a selector string through postcss-selector-parser
 */
function parse(rawSelector, rule) {
  let nodes
  try {
    parser(parsed => {
      nodes = parsed
    }).processSync(rawSelector)
  } catch (e) {
    if (rawSelector.includes(':')) {
=======
var postcss = require('postcss')
var parser = require('postcss-selector-parser')

function parse (str, rule) {
  var nodes
  var saver = parser(function (parsed) {
    nodes = parsed
  })
  try {
    saver.processSync(str)
  } catch (e) {
    if (str.indexOf(':') !== -1) {
>>>>>>> d64897a83ee05dfaaf4e857f6a92bd00c77921de
      throw rule ? rule.error('Missed semicolon') : e
    } else {
      throw rule ? rule.error(e.message) : e
    }
  }
  return nodes.at(0)
}

<<<<<<< HEAD
/**
 * Replaces the "&" token in a node's selector with the parent selector
 * similar to what SCSS does.
 *
 * Mutates the nodes list
 */
function interpolateAmpInSelector(nodes, parent) {
  let replaced = false
  nodes.each(node => {
    if (node.type === 'nesting') {
      let clonedParent = parent.clone({})
      if (node.value !== '&') {
        node.replaceWith(
          parse(node.value.replace('&', clonedParent.toString()))
        )
      } else {
        node.replaceWith(clonedParent)
      }
      replaced = true
    } else if ('nodes' in node && node.nodes) {
      if (interpolateAmpInSelector(node, parent)) {
=======
function replace (nodes, parent) {
  var replaced = false
  nodes.each(function (i) {
    if (i.type === 'nesting') {
      var clonedParent = parent.clone()
      if (i.value !== '&') {
        i.replaceWith(parse(i.value.replace('&', clonedParent.toString())))
      } else {
        i.replaceWith(clonedParent)
      }
      replaced = true
    } else if (i.nodes) {
      if (replace(i, parent)) {
>>>>>>> d64897a83ee05dfaaf4e857f6a92bd00c77921de
        replaced = true
      }
    }
  })
  return replaced
}

<<<<<<< HEAD
/**
 * Combines parent and child selectors, in a SCSS-like way
 */
function mergeSelectors(parent, child) {
  let merged = []
  parent.selectors.forEach(sel => {
    let parentNode = parse(sel, parent)

    child.selectors.forEach(selector => {
      if (!selector) {
        return
      }
      let node = parse(selector, child)
      let replaced = interpolateAmpInSelector(node, parentNode)
      if (!replaced) {
        node.prepend(parser.combinator({ value: ' ' }))
        node.prepend(parentNode.clone({}))
      }
      merged.push(node.toString())
    })
  })
  return merged
}

/**
 * Move a child and its preceeding comment(s) to after "after"
 */
function breakOut(child, after) {
  let prev = child.prev()
  after.after(child)
  while (prev && prev.type === 'comment') {
    let nextPrev = prev.prev()
    after.after(prev)
    prev = nextPrev
  }
  return child
}

function createFnAtruleChilds(bubble) {
  return function atruleChilds(rule, atrule, bubbling, mergeSels = bubbling) {
    let children = []
    atrule.each(child => {
      if (child.type === 'rule' && bubbling) {
        if (mergeSels) {
          child.selectors = mergeSelectors(rule, child)
        }
      } else if (child.type === 'atrule' && child.nodes) {
        if (bubble[child.name]) {
          atruleChilds(rule, child, mergeSels)
        } else if (atrule[rootRuleMergeSel] !== false) {
          children.push(child)
        }
      } else {
        children.push(child)
      }
    })
    if (bubbling) {
      if (children.length) {
        let clone = rule.clone({ nodes: [] })
        for (let child of children) {
          clone.append(child)
        }
        atrule.prepend(clone)
      }
=======
function selectors (parent, child) {
  var result = []
  parent.selectors.forEach(function (i) {
    var parentNode = parse(i, parent)

    child.selectors.forEach(function (j) {
      var node = parse(j, child)
      var replaced = replace(node, parentNode)
      if (!replaced) {
        node.prepend(parser.combinator({ value: ' ' }))
        node.prepend(parentNode.clone())
      }
      result.push(node.toString())
    })
  })
  return result
}

function pickComment (comment, after) {
  if (comment && comment.type === 'comment') {
    after.after(comment)
    return comment
  } else {
    return after
  }
}

function atruleChilds (rule, atrule, bubbling) {
  var children = []
  atrule.each(function (child) {
    if (child.type === 'comment') {
      children.push(child)
    } else if (child.type === 'decl') {
      children.push(child)
    } else if (child.type === 'rule' && bubbling) {
      child.selectors = selectors(rule, child)
    } else if (child.type === 'atrule') {
      atruleChilds(rule, child, bubbling)
    }
  })
  if (bubbling) {
    if (children.length) {
      var clone = rule.clone({ nodes: [] })
      for (var i = 0; i < children.length; i++) {
        clone.append(children[i])
      }
      atrule.prepend(clone)
>>>>>>> d64897a83ee05dfaaf4e857f6a92bd00c77921de
    }
  }
}

<<<<<<< HEAD
function pickDeclarations(selector, declarations, after) {
  let parent = new Rule({
    selector,
    nodes: []
  })
  parent.append(declarations)
=======
function pickDeclarations (selector, declarations, after) {
  var parent = postcss.rule({
    selector: selector,
    nodes: []
  })

  for (var i = 0; i < declarations.length; i++) {
    parent.append(declarations[i])
  }

>>>>>>> d64897a83ee05dfaaf4e857f6a92bd00c77921de
  after.after(parent)
  return parent
}

<<<<<<< HEAD
function atruleNames(defaults, custom) {
  let list = {}
  for (let name of defaults) {
    list[name] = true
  }
  if (custom) {
    for (let name of custom) {
      list[name.replace(/^@/, '')] = true
=======
function processRule (rule, bubble, unwrap, preserveEmpty) {
  var unwrapped = false
  var after = rule
  var copyDeclarations = false
  var declarations = []

  rule.each(function (child) {
    if (child.type === 'rule') {
      if (declarations.length) {
        after = pickDeclarations(rule.selector, declarations, after)
        declarations = []
      }

      copyDeclarations = true
      unwrapped = true
      child.selectors = selectors(rule, child)
      after = pickComment(child.prev(), after)
      after.after(child)
      after = child
    } else if (child.type === 'atrule') {
      copyDeclarations = false

      if (declarations.length) {
        after = pickDeclarations(rule.selector, declarations, after)
        declarations = []
      }

      if (child.name === 'at-root') {
        unwrapped = true
        atruleChilds(rule, child, false)

        var nodes = child.nodes
        if (child.params) {
          nodes = postcss.rule({
            selector: child.params,
            nodes: nodes
          })
        }

        after.after(nodes)
        after = nodes
        child.remove()
      } else if (bubble[child.name]) {
        unwrapped = true
        atruleChilds(rule, child, true)
        after = pickComment(child.prev(), after)
        after.after(child)
        after = child
      } else if (unwrap[child.name]) {
        unwrapped = true
        atruleChilds(rule, child, false)
        after = pickComment(child.prev(), after)
        after.after(child)
        after = child
      }
    } else if (child.type === 'decl' && copyDeclarations) {
      declarations.push(child)
    }
  })

  if (declarations.length) {
    after = pickDeclarations(rule.selector, declarations, after)
  }

  if (unwrapped && preserveEmpty !== true) {
    rule.raws.semicolon = true
    if (rule.nodes.length === 0) rule.remove()
  }
}

function atruleNames (defaults, custom) {
  var list = { }
  var i, name
  for (i = 0; i < defaults.length; i++) {
    list[defaults[i]] = true
  }
  if (custom) {
    for (i = 0; i < custom.length; i++) {
      name = custom[i].replace(/^@/, '')
      list[name] = true
>>>>>>> d64897a83ee05dfaaf4e857f6a92bd00c77921de
    }
  }
  return list
}

<<<<<<< HEAD
function parseRootRuleParams(params) {
  params = params.trim()
  let braceBlock = params.match(/^\((.*)\)$/)
  if (!braceBlock) {
    return { type: 'basic', selector: params }
  }
  let bits = braceBlock[1].match(/^(with(?:out)?):(.+)$/)
  if (bits) {
    let allowlist = bits[1] === 'with'
    let rules = Object.fromEntries(
      bits[2]
        .trim()
        .split(/\s+/)
        .map(name => [name, true])
    )
    if (allowlist && rules.all) {
      return { type: 'noop' }
    }
    let escapes = rule => !!rules[rule]
    if (rules.all) {
      escapes = () => true
    } else if (allowlist) {
      escapes = rule => (rule === 'all' ? false : !rules[rule])
    }

    return {
      type: 'withrules',
      escapes
    }
  }
  // Unrecognized brace block
  return { type: 'unknown' }
}

function getAncestorRules(leaf) {
  let lineage = []
  let parent = leaf.parent

  while (parent && parent instanceof AtRule) {
    lineage.push(parent)
    parent = parent.parent
  }
  return lineage
}

function unwrapRootRule(rule) {
  let escapes = rule[rootRuleEscapes]

  if (!escapes) {
    rule.after(rule.nodes)
  } else {
    let nodes = rule.nodes

    let topEscaped
    let topEscapedIdx = -1
    let breakoutLeaf
    let breakoutRoot
    let clone

    let lineage = getAncestorRules(rule)
    lineage.forEach((parent, i) => {
      if (escapes(parent.name)) {
        topEscaped = parent
        topEscapedIdx = i
        breakoutRoot = clone
      } else {
        let oldClone = clone
        clone = parent.clone({ nodes: [] })
        oldClone && clone.append(oldClone)
        breakoutLeaf = breakoutLeaf || clone
      }
    })

    if (!topEscaped) {
      rule.after(nodes)
    } else if (!breakoutRoot) {
      topEscaped.after(nodes)
    } else {
      let leaf = breakoutLeaf
      leaf.append(nodes)
      topEscaped.after(breakoutRoot)
    }

    if (rule.next() && topEscaped) {
      let restRoot
      lineage.slice(0, topEscapedIdx + 1).forEach((parent, i, arr) => {
        let oldRoot = restRoot
        restRoot = parent.clone({ nodes: [] })
        oldRoot && restRoot.append(oldRoot)

        let nextSibs = []
        let _child = arr[i - 1] || rule
        let next = _child.next()
        while (next) {
          nextSibs.push(next)
          next = next.next()
        }
        restRoot.append(nextSibs)
      })
      restRoot && (breakoutRoot || nodes[nodes.length - 1]).after(restRoot)
    }
  }

  rule.remove()
}

const rootRuleMergeSel = Symbol('rootRuleMergeSel')
const rootRuleEscapes = Symbol('rootRuleEscapes')

function normalizeRootRule(rule) {
  let { params } = rule
  let { type, selector, escapes } = parseRootRuleParams(params)
  if (type === 'unknown') {
    throw rule.error(
      `Unknown @${rule.name} parameter ${JSON.stringify(params)}`
    )
  }
  if (type === 'basic' && selector) {
    let selectorBlock = new Rule({ selector, nodes: rule.nodes })
    rule.removeAll()
    rule.append(selectorBlock)
  }
  rule[rootRuleEscapes] = escapes
  rule[rootRuleMergeSel] = escapes ? !escapes('all') : type === 'noop'
}

const hasRootRule = Symbol('hasRootRule')

module.exports = (opts = {}) => {
  let bubble = atruleNames(['media', 'supports', 'layer'], opts.bubble)
  let atruleChilds = createFnAtruleChilds(bubble)
  let unwrap = atruleNames(
    [
      'document',
      'font-face',
      'keyframes',
      '-webkit-keyframes',
      '-moz-keyframes'
    ],
    opts.unwrap
  )
  let rootRuleName = (opts.rootRuleName || 'at-root').replace(/^@/, '')
  let preserveEmpty = opts.preserveEmpty

  return {
    postcssPlugin: 'postcss-nested',

    Once(root) {
      root.walkAtRules(rootRuleName, node => {
        normalizeRootRule(node)
        root[hasRootRule] = true
      })
    },

    Rule(rule) {
      let unwrapped = false
      let after = rule
      let copyDeclarations = false
      let declarations = []

      rule.each(child => {
        if (child.type === 'rule') {
          if (declarations.length) {
            after = pickDeclarations(rule.selector, declarations, after)
            declarations = []
          }

          copyDeclarations = true
          unwrapped = true
          child.selectors = mergeSelectors(rule, child)
          after = breakOut(child, after)
        } else if (child.type === 'atrule') {
          if (declarations.length) {
            after = pickDeclarations(rule.selector, declarations, after)
            declarations = []
          }
          if (child.name === rootRuleName) {
            unwrapped = true
            atruleChilds(rule, child, true, child[rootRuleMergeSel])
            after = breakOut(child, after)
          } else if (bubble[child.name]) {
            copyDeclarations = true
            unwrapped = true
            atruleChilds(rule, child, true)
            after = breakOut(child, after)
          } else if (unwrap[child.name]) {
            copyDeclarations = true
            unwrapped = true
            atruleChilds(rule, child, false)
            after = breakOut(child, after)
          } else if (copyDeclarations) {
            declarations.push(child)
          }
        } else if (child.type === 'decl' && copyDeclarations) {
          declarations.push(child)
        }
      })

      if (declarations.length) {
        after = pickDeclarations(rule.selector, declarations, after)
      }

      if (unwrapped && preserveEmpty !== true) {
        rule.raws.semicolon = true
        if (rule.nodes.length === 0) rule.remove()
      }
    },

    RootExit(root) {
      if (root[hasRootRule]) {
        root.walkAtRules(rootRuleName, unwrapRootRule)
        root[hasRootRule] = false
      }
    }
  }
}
module.exports.postcss = true
=======
module.exports = postcss.plugin('postcss-nested', function (opts) {
  if (!opts) opts = { }
  var bubble = atruleNames(['media', 'supports'], opts.bubble)
  var unwrap = atruleNames(['document', 'font-face', 'keyframes'], opts.unwrap)
  var preserveEmpty = opts ? opts.preserveEmpty : false

  var process = function (node) {
    node.each(function (child) {
      if (child.type === 'rule') {
        processRule(child, bubble, unwrap, preserveEmpty)
      } else if (child.type === 'atrule') {
        process(child)
      }
    })
  }
  return process
})
>>>>>>> d64897a83ee05dfaaf4e857f6a92bd00c77921de
